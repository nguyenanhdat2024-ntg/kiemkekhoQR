<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="·ª®ng d·ª•ng qu√©t m√£ v·∫°ch v√† qu·∫£n l√Ω ki·ªÉm k√™ nhanh ch√≥ng, hi·ªáu qu·∫£" />
  <meta name="keywords" content="qu√©t m√£ v·∫°ch, ki·ªÉm k√™, inventory, barcode scanner" />
  <!-- L∆∞u √Ω CSP t·ªëi gi·∫£n cho v√≠ d·ª•; tu·ª≥ m√¥i tr∆∞·ªùng b·∫°n c√≥ th·ªÉ th·∫Øt ch·∫∑t l·∫°i -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://unpkg.com; style-src 'self' 'unsafe-inline'; connect-src 'self' https://* data: blob:;">
  <title>Qu√©t M√£ V·∫°ch Nhanh ‚Äî S·ª≠a l·ªói camera</title>
  <style>
    :root {
      --primary: #1366d6;
      --primary-dark: #0d4ba3;
      --success: #28a745;
      --danger: #dc3545;
      --warning: #ffc107;
      --light: #f8f9fa;
      --dark: #343a40;
      --gray: #6c757d;
      --border: #e6e6e6;
      --shadow: 0 1px 4px rgba(0,0,0,0.03);
    }
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      margin: 0; padding: 12px; color: var(--dark); background-color: #f5f7fa;
      line-height: 1.5;
    }
    h1 { font-size: 22px; margin: 6px 0 12px; color: var(--primary); text-align:center; }
    .grid { display:grid; grid-template-columns:1fr 360px; gap:16px; max-width:1200px; margin:0 auto; align-items:start; }
    .card { border:1px solid var(--border); padding:16px; border-radius:8px; background:white; box-shadow:var(--shadow); margin-bottom:12px;}
    video { width:100%; height:auto; border-radius:6px; background:#000; min-height:200px; }
    label { display:block; margin-top:12px; margin-bottom:4px; font-size:14px; font-weight:500; }
    input[type=number], input[type=text], select { width:100%; padding:10px; border-radius:6px; border:1px solid #ccc; font-size:14px; }
    button { padding:10px 14px; border-radius:6px; border:0; background:var(--primary); color:white; cursor:pointer; font-size:14px; font-weight:500; display:inline-flex; gap:6px; align-items:center; justify-content:center; }
    button.ghost { background:#f2f2f2; color:#222; border:1px solid #ddd; }
    button.small { padding:8px 10px; font-size:13px; }
    button.success { background:var(--success); }
    button.danger { background:var(--danger); }
    .controls { display:flex; gap:8px; margin-top:12px; flex-wrap:wrap; align-items:center; }
    table { width:100%; border-collapse:collapse; margin-top:8px; font-size:14px; }
    th, td { padding:10px; border-bottom:1px solid #eee; text-align:left; }
    th { background:#f8f9fa; font-weight:600; }
    .empty-state { text-align:center; padding:20px; color:var(--gray); }
    #log { font-size:13px; margin-top:12px; min-height:40px; padding:8px; border-radius:4px; background:#fff9e6; border-left:4px solid var(--warning); }
    .status-success { background:#f0f9f0; border-left-color:var(--success); color:#155724; }
    .status-error { background:#fdf2f2; border-left-color:var(--danger); color:#721c24; }
    .camera-container { position:relative; margin-bottom:12px; }
    .camera-overlay { position:absolute; top:0; left:0; width:100%; height:100%; display:flex; align-items:center; justify-content:center; pointer-events:none; }
    .scan-area { width:200px; height:100px; border:2px solid var(--primary); border-radius:8px; box-shadow:0 0 0 9999px rgba(0,0,0,0.4); }
    .capture-btn { position:absolute; bottom:16px; left:50%; transform:translateX(-50%); width:60px; height:60px; border-radius:50%; background:var(--primary); display:flex; align-items:center; justify-content:center; color:white; font-size:24px; cursor:pointer; box-shadow:0 4px 8px rgba(0,0,0,0.3); z-index:10; }
    .flash-effect { position:absolute; top:0; left:0; width:100%; height:100%; background:white; opacity:0; pointer-events:none; border-radius:6px; }
    @keyframes flash { 0%{opacity:0}50%{opacity:0.8}100%{opacity:0} }
    .flash-active { animation:flash 0.3s ease; }
    .notification { position:fixed; top:20px; right:20px; padding:12px 16px; border-radius:6px; background:white; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:1000; display:flex; gap:8px; transform:translateX(150%); transition:transform .3s ease; }
    .notification.show { transform:translateX(0); }
    .notification.success { border-left:4px solid var(--success); }
    .notification.error { border-left:4px solid var(--danger); }
    footer { margin-top:16px; font-size:12px; color:var(--gray); text-align:center; padding:8px; }
    @media (max-width:900px){ .grid{grid-template-columns:1fr;} .scan-area{width:180px;height:90px;} }
    @media (max-width:480px){ body{padding:8px;} .controls{flex-direction:column;align-items:stretch;} .capture-btn{bottom:12px;} }
  </style>
</head>
<body>
  <h1>üì¶ ·ª®ng d·ª•ng qu√©t m√£ v·∫°ch ‚Äî (S·ª≠a l·ªói camera)</h1>

  <div class="grid">
    <div class="card">
      <div class="camera-container">
        <!-- th√™m autoplay muted playsinline ƒë·ªÉ tr√¨nh duy·ªát cho ph√©p play t·ª± ƒë·ªông -->
        <video id="video" playsinline autoplay muted></video>
        <div class="camera-overlay"><div class="scan-area"></div></div>
        <div class="capture-btn" id="captureBtn" title="Ch·ª•p & qu√©t">üì∑</div>
        <div class="flash-effect" id="flashEffect"></div>
      </div>

      <div class="controls" style="align-items:center;">
        <label style="margin:0;">Camera</label>
        <select id="deviceSelect" style="min-width:160px;"></select>
        <button id="openCameraBtn" class="small">üöÄ M·ªü camera</button>
        <button id="toggleAutoBtn" class="small ghost">üîÅ Qu√©t t·ª± ƒë·ªông: ON</button>
        <button id="flashToggle" class="small ghost" title="B·∫≠t/t·∫Øt ƒë√®n (n·∫øu h·ªó tr·ª£)">üî¶ Flash</button>
      </div>

      <label>M√£ g·ªëc:</label>
      <div class="code-display code-original" id="decoded">(ch∆∞a qu√©t)</div>

      <div class="controls">
        <div>
          <label for="filterStart" style="margin-top:0;">V·ªã tr√≠ b·∫Øt ƒë·∫ßu</label>
          <input id="filterStart" type="number" min="1" value="1" style="width:120px" />
        </div>
        <div>
          <label for="filterLength" style="margin-top:0;">S·ªë k√Ω t·ª±</label>
          <input id="filterLength" type="number" min="0" value="0" style="width:120px" placeholder="0 = ƒë·∫øn cu·ªëi" />
        </div>
      </div>

      <label>M√£ sau l·ªçc:</label>
      <div class="code-display code-filtered" id="filtered">(ch∆∞a c√≥)</div>

      <label for="qty">S·ªë l∆∞·ª£ng</label>
      <div class="controls">
        <div style="display:flex; gap:8px; align-items:center;">
          <button id="dec" class="ghost small">‚àí</button>
          <input id="qty" type="number" value="1" min="1" style="width:80px; text-align:center;" />
          <button id="inc" class="ghost small">Ôºã</button>
        </div>
        <button id="addBtn" class="success">‚ûï Th√™m</button>
      </div>

      <div class="controls">
        <div class="search-box" style="flex:1; position:relative;">
          <span style="position:absolute; left:10px; top:50%; transform:translateY(-50%); color:var(--gray)">üîç</span>
          <input id="searchInput" type="text" placeholder="T√¨m ki·∫øm trong danh s√°ch..." style="padding-left:36px; width:100%;" />
        </div>
        <button id="exportBtn" class="small">üì• Xu·∫•t CSV</button>
        <button id="importBtn" class="small ghost">üì§ Nh·∫≠p CSV</button>
        <input id="importFile" type="file" accept=".csv,text/csv" style="display:none" />
      </div>

      <div id="log" class="status-success">Chu·∫©n b·ªã...</div>
    </div>

    <div class="card">
      <h3>üìã Danh s√°ch ki·ªÉm k√™</h3>
      <div style="max-height:400px; overflow-y:auto;">
        <table id="table">
          <thead>
            <tr><th>M√£</th><th>S·ªë l∆∞·ª£ng</th><th>H√†nh ƒë·ªông</th></tr>
          </thead>
          <tbody><tr><td colspan="3" class="empty-state">Danh s√°ch tr·ªëng</td></tr></tbody>
        </table>
      </div>
      <div style="margin-top:12px; padding:8px; background:#f8f9fa; border-radius:4px;">
        T·ªïng m·ª•c: <strong id="count">0</strong> ‚Äî T·ªïng s·ªë l∆∞·ª£ng: <strong id="total">0</strong>
      </div>
    </div>
  </div>

  <footer>
    ·ª®ng d·ª•ng ch·∫°y t·ªët nh·∫•t tr√™n HTTPS ho·∫∑c localhost. D·ªØ li·ªáu l∆∞u c·ª•c b·ªô trong tr√¨nh duy·ªát.
  </footer>

  <div id="notification" class="notification"></div>

  <!-- ZXing library -->
  <script src="https://unpkg.com/@zxing/library@0.18.6"></script>

  <script>
    // ---------- DOM ----------
    const video = document.getElementById('video');
    const deviceSelect = document.getElementById('deviceSelect');
    const openCameraBtn = document.getElementById('openCameraBtn');
    const toggleAutoBtn = document.getElementById('toggleAutoBtn');
    const flashToggle = document.getElementById('flashToggle');
    const captureBtn = document.getElementById('captureBtn');
    const decodedEl = document.getElementById('decoded');
    const filteredEl = document.getElementById('filtered');
    const qtyInput = document.getElementById('qty');
    const addBtn = document.getElementById('addBtn');
    const decBtn = document.getElementById('dec');
    const incBtn = document.getElementById('inc');
    const tableBody = document.querySelector('#table tbody');
    const countEl = document.getElementById('count');
    const totalEl = document.getElementById('total');
    const clearBtn = document.getElementById('clearBtn');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFile = document.getElementById('importFile');
    const filterStart = document.getElementById('filterStart');
    const filterLength = document.getElementById('filterLength');
    const logEl = document.getElementById('log');
    const searchInput = document.getElementById('searchInput');
    const notification = document.getElementById('notification');
    const toggleAuto = toggleAutoBtn;
    const flashEffect = document.getElementById('flashEffect');

    // ---------- State ----------
    const inventory = new Map();
    const codeReader = new ZXing.BrowserMultiFormatReader();
    let currentStream = null;
    let selectedDeviceId = null;
    let lastCode = '';
    let lastTime = 0;
    let isAutoScan = true;
    let isScanning = false;
    let currentTrack = null;
    let torchOn = false;

    // ---------- Helpers ----------
    function showNotification(msg, type = 'success', duration = 3000) {
      notification.textContent = msg;
      notification.className = `notification ${type} show`;
      setTimeout(() => notification.classList.remove('show'), duration);
    }

    function log(msg, typeClass = 'status-success') {
      logEl.textContent = msg;
      logEl.className = typeClass;
    }

    function escapeHtml(s) {
      return String(s || '').replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
    }

    function escapeAttr(s) {
      return String(s || '').replace(/"/g, '&quot;');
    }

    function applyFilter(code) {
      const start = Math.max(0, Number(filterStart.value || 1) - 1);
      const len = Math.max(0, Number(filterLength.value || 0));
      if (!code) return '';
      if (len > 0) return code.substr(start, len);
      return code.substr(start);
    }

    function saveLocal() {
      try {
        localStorage.setItem('inventory', JSON.stringify([...inventory.values()]));
        localStorage.setItem('inventory_filter', JSON.stringify({ start: filterStart.value, length: filterLength.value }));
      } catch(e) { console.warn('saveLocal', e); }
    }

    function loadLocal() {
      try {
        const arr = JSON.parse(localStorage.getItem('inventory') || '[]');
        inventory.clear();
        for (const v of arr) if (v && v.code) inventory.set(v.code, v);
        const filterSettings = JSON.parse(localStorage.getItem('inventory_filter') || '{}');
        if (filterSettings.start) filterStart.value = filterSettings.start;
        if (filterSettings.length !== undefined) filterLength.value = filterSettings.length;
      } catch(e) { console.warn('loadLocal', e); }
    }

    function renderTable(searchTerm = '') {
      tableBody.innerHTML = '';
      let total = 0; let hasItems = false;
      for (const [k, v] of inventory.entries()) {
        if (searchTerm && !v.code.toLowerCase().includes(searchTerm.toLowerCase())) continue;
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${escapeHtml(v.code)}</td>
          <td>${v.qty}</td>
          <td><button data-code="${escapeAttr(v.code)}" class="ghost small danger">üóëÔ∏è X√≥a</button></td>
        `;
        tableBody.appendChild(tr);
        total += Number(v.qty) || 0;
        hasItems = true;
      }
      if (!hasItems) {
        tableBody.innerHTML = `<tr><td colspan="3" class="empty-state">${searchTerm ? 'Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ ph√π h·ª£p' : 'Danh s√°ch tr·ªëng'}</td></tr>`;
      }
      countEl.textContent = inventory.size;
      totalEl.textContent = total;
      tableBody.querySelectorAll('button').forEach(b => {
        b.addEventListener('click', ev => {
          const code = ev.currentTarget.getAttribute('data-code');
          if (confirm(`X√≥a s·∫£n ph·∫©m "${code}"?`)) {
            inventory.delete(code);
            saveLocal();
            renderTable(searchInput.value);
            showNotification('ƒê√£ x√≥a s·∫£n ph·∫©m kh·ªèi danh s√°ch', 'success');
          }
        });
      });
    }

    // ---------- Camera & Devices ----------
    function stopStream() {
      if (currentStream) {
        currentStream.getTracks().forEach(t => t.stop());
        currentStream = null;
      }
      try { codeReader.reset(); } catch(e){}
      video.srcObject = null;
      isScanning = false;
      currentTrack = null;
    }

    // enumerate devices (after permission) and fill select
    async function listCameras() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoInputs = devices.filter(d => d.kind === 'videoinput');
        deviceSelect.innerHTML = '';
        videoInputs.forEach((d, i) => {
          const opt = document.createElement('option');
          opt.value = d.deviceId;
          opt.textContent = d.label || `Camera ${i+1}`;
          deviceSelect.appendChild(opt);
        });
        if (videoInputs.length) {
          // try pick rear if label contains back/rear/environment
          let back = videoInputs.find(d => /back|rear|environment|wide/i.test(d.label));
          if (!back) back = videoInputs[videoInputs.length-1];
          selectedDeviceId = back.deviceId;
          deviceSelect.value = selectedDeviceId;
          log(`T√¨m th·∫•y ${videoInputs.length} camera. M·∫∑c ƒë·ªãnh: ${back.label || deviceSelect.options[0].text}`, 'status-success');
        } else {
          log('Kh√¥ng t√¨m th·∫•y camera n√†o.', 'status-error');
        }
      } catch (e) {
        console.warn('listCameras error', e);
        log('L·ªói khi li·ªát k√™ thi·∫øt b·ªã: ' + (e?.message || e), 'status-error');
      }
    }

    async function startCamera(deviceId = null) {
      // ensure secure context
      if (!('mediaDevices' in navigator) || !navigator.mediaDevices.getUserMedia) {
        log('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Camera API.', 'status-error');
        showNotification('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ camera', 'error', 5000);
        return;
      }

      stopStream();

      // constraints
      const constraints = {
        video: {
          width: { ideal: 1280 },
          height: { ideal: 720 },
          ...(deviceId ? { deviceId: { exact: deviceId } } : { facingMode: { ideal: 'environment' } })
        },
        audio: false
      };

      try {
        currentStream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = currentStream;
        await video.play();
        // store primary track for torch control
        currentTrack = currentStream.getVideoTracks()[0] || null;
        isScanning = false; // will start when user enables auto-scan
        log('Camera ƒë√£ k·∫øt n·ªëi. B·∫°n c√≥ th·ªÉ qu√©t m√£.', 'status-success');

        // After permission granted, list devices to get labels
        await listCameras();

        // If auto-scan enabled, start decoder
        if (isAutoScan) startAutoScan();

      } catch (e) {
        console.error('startCamera error', e);
        if (e && e.name === 'NotAllowedError') {
          log('Quy·ªÅn truy c·∫≠p camera b·ªã t·ª´ ch·ªëi. Vui l√≤ng c·∫•p quy·ªÅn.', 'status-error');
          showNotification('Vui l√≤ng c·∫•p quy·ªÅn camera cho trang n√†y', 'error', 6000);
        } else if (e && e.name === 'NotFoundError') {
          log('Kh√¥ng t√¨m th·∫•y camera (NotFound).', 'status-error');
          showNotification('Kh√¥ng t√¨m th·∫•y camera tr√™n thi·∫øt b·ªã', 'error', 5000);
        } else {
          log('L·ªói khi m·ªü camera: ' + (e?.message || e), 'status-error');
          showNotification('L·ªói khi m·ªü camera: ' + (e?.message || e), 'error', 5000);
        }
      }
    }

    // Start ZXing auto decode from the selected device
    function startAutoScan() {
      if (!currentStream) {
        log('Camera ch∆∞a s·∫µn s√†ng ƒë·ªÉ qu√©t.', 'status-error');
        return;
      }
      if (isScanning) return;
      try {
        // decodeFromVideoDevice handles internal getUserMedia if deviceId passed.
        // But we already have currentStream ‚Äî so we use decodeFromVideoElement for continuous decoding.
        codeReader.decodeFromVideoElementContinuously(video, (result, err) => {
          if (result) handleResult(result.text);
          else if (err && !(err instanceof ZXing.NotFoundException)) {
            console.warn('Decode error:', err);
          }
        });
        isScanning = true;
        log('ƒêang qu√©t t·ª± ƒë·ªông...', 'status-success');
      } catch (e) {
        console.error('startAutoScan error', e);
        log('L·ªói khi b·∫≠t qu√©t t·ª± ƒë·ªông: ' + (e?.message || e), 'status-error');
      }
    }

    function stopAutoScan() {
      try {
        codeReader.reset();
      } catch (e) {
        console.warn('stopAutoScan reset err', e);
      }
      isScanning = false;
    }

    // Single-frame capture & decode
    async function captureImageAndDecode() {
      if (!currentStream) {
        showNotification('Camera ch∆∞a s·∫µn s√†ng!', 'error');
        return;
      }
      // flash visual
      flashEffect.classList.add('flash-active');
      setTimeout(()=>flashEffect.classList.remove('flash-active'), 300);

      try {
        // draw current frame to canvas and decode using ZXing from canvas blob
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth || 1280;
        canvas.height = video.videoHeight || 720;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        // convert to blob
        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
        if (!blob) { showNotification('Kh√¥ng th·ªÉ l·∫•y ·∫£nh t·ª´ video', 'error'); return; }

        // create an <img> to feed into ZXing.decodeFromImageElement
        const img = new Image();
        img.src = URL.createObjectURL(blob);
        img.onload = async () => {
          try {
            const result = await codeReader.decodeFromImageElement(img);
            if (result && result.text) {
              handleResult(result.text);
              showNotification('ƒê√£ ch·ª•p v√† qu√©t m√£ th√†nh c√¥ng', 'success', 2000);
            } else {
              showNotification('Kh√¥ng t√¨m th·∫•y m√£ v·∫°ch trong h√¨nh', 'warning', 2000);
            }
          } catch (err) {
            console.warn('decodeFromImageElement err', err);
            showNotification('Kh√¥ng th·ªÉ ƒë·ªçc m√£ v·∫°ch t·ª´ ·∫£nh', 'error', 2500);
          } finally {
            URL.revokeObjectURL(img.src);
          }
        };
        img.onerror = () => {
          showNotification('L·ªói t·∫£i ·∫£nh ƒë·ªÉ qu√©t', 'error');
          URL.revokeObjectURL(img.src);
        };
      } catch (e) {
        console.error('captureImageAndDecode error', e);
        showNotification('L·ªói khi ch·ª•p ·∫£nh', 'error');
      }
    }

    // Torch control (ƒë√®n pin) ‚Äî n·∫øu thi·∫øt b·ªã h·ªó tr·ª£
    async function setTorch(on) {
      if (!currentTrack) {
        showNotification('Kh√¥ng c√≥ stream ƒë·ªÉ ƒëi·ªÅu khi·ªÉn torch', 'warning');
        return;
      }
      try {
        const capabilities = currentTrack.getCapabilities();
        if (!capabilities.torch) {
          showNotification('Thi·∫øt b·ªã kh√¥ng h·ªó tr·ª£ torch', 'warning');
          return;
        }
        await currentTrack.applyConstraints({ advanced: [{ torch: on }] });
        torchOn = on;
        flashToggle.classList.toggle('warning', torchOn);
        flashToggle.textContent = torchOn ? 'üí° Flash' : 'üî¶ Flash';
        showNotification(torchOn ? 'Torch b·∫≠t' : 'Torch t·∫Øt', 'success');
      } catch (e) {
        console.warn('setTorch error', e);
        showNotification('Kh√¥ng th·ªÉ ƒëi·ªÅu khi·ªÉn torch: ' + (e?.message || e), 'error');
      }
    }

    // ---------- Barcode handling ----------
    function handleResult(code) {
      const now = Date.now();
      if (code === lastCode && now - lastTime < 1500) return;
      lastCode = code; lastTime = now;
      decodedEl.textContent = code;
      const filtered = applyFilter(code);
      filteredEl.textContent = filtered || '(tr·ªëng)';
      if (!inventory.has(filtered)) {
        addBtn.focus();
      } else {
        qtyInput.focus();
        qtyInput.select();
      }
      showNotification(`ƒê√£ qu√©t m√£: ${code}`, 'success', 1500);
    }

    function validateQuantity() {
      let value = parseInt(qtyInput.value);
      if (isNaN(value) || value < 1) { qtyInput.value = 1; return 1; }
      return value;
    }

    // ---------- Event wiring ----------
    decBtn.addEventListener('click', ()=> { qtyInput.value = Math.max(1, Number(qtyInput.value||1) - 1); validateQuantity(); });
    incBtn.addEventListener('click', ()=> { qtyInput.value = Number(qtyInput.value||0) + 1; validateQuantity(); });
    qtyInput.addEventListener('change', validateQuantity);
    qtyInput.addEventListener('blur', validateQuantity);

    addBtn.addEventListener('click', () => {
      const code = filteredEl.textContent && filteredEl.textContent !== '(ch∆∞a c√≥)' && filteredEl.textContent !== '(tr·ªëng)' ? filteredEl.textContent.trim() : null;
      const qty = validateQuantity();
      if (!code) { showNotification('Ch∆∞a c√≥ m√£ ƒë·ªÉ th√™m!', 'error'); return; }
      if (inventory.has(code)) {
        inventory.get(code).qty += qty;
        showNotification(`ƒê√£ c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng cho "${code}"`, 'success');
      } else {
        inventory.set(code, { code, qty });
        showNotification(`ƒê√£ th√™m s·∫£n ph·∫©m "${code}" v√†o danh s√°ch`, 'success');
      }
      saveLocal(); renderTable(searchInput.value); qtyInput.value = 1;
    });

    exportBtn.addEventListener('click', ()=> {
      if (inventory.size === 0) { showNotification('Danh s√°ch tr·ªëng, kh√¥ng c√≥ g√¨ ƒë·ªÉ xu·∫•t!', 'warning'); return; }
      const rows = [['M√£','S·ªë l∆∞·ª£ng']];
      for (const [k,v] of inventory.entries()) rows.push([v.code, v.qty]);
      // add BOM so Excel ƒë·ªçc ti·∫øng Vi·ªát t·ªët h∆°n
      const csv = rows.map(r => r.map(c => '"' + String(c).replace(/"/g,'""') + '"').join(',')).join('\n');
      const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url;
      a.download = `inventory-${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      showNotification(`ƒê√£ xu·∫•t ${inventory.size} m·ª•c ra file CSV`, 'success');
    });

    importBtn.addEventListener('click', ()=> importFile.click());
    importFile.addEventListener('change', e => {
      const f = e.target.files[0]; if (!f) return;
      const reader = new FileReader();
      reader.onload = ()=> {
        try {
          const lines = reader.result.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
          let imported = 0;
          for (let i=1;i<lines.length;i++){
            const parts = lines[i].split(',').map(p => p.replace(/^"|"$/g,'').trim());
            if (parts.length<2) continue;
            const code = parts[0]||`imp-${Date.now()}-${i}`;
            const qty = Number(parts[1])||0;
            if (qty>0){
              if (inventory.has(code)) inventory.get(code).qty += qty;
              else inventory.set(code, { code, qty });
              imported++;
            }
          }
          saveLocal(); renderTable(searchInput.value);
          showNotification(`ƒê√£ nh·∫≠p ${imported} m·ª•c t·ª´ file CSV`, 'success');
        } catch(err){
          showNotification('L·ªói khi ƒë·ªçc file CSV: ' + err.message, 'error');
        }
        importFile.value = '';
      };
      reader.onerror = ()=> { showNotification('L·ªói khi ƒë·ªçc file', 'error'); importFile.value = ''; };
      reader.readAsText(f);
    });

    deviceSelect.addEventListener('change', () => {
      selectedDeviceId = deviceSelect.value;
      // restart camera with selected device
      startCamera(selectedDeviceId);
    });

    openCameraBtn.addEventListener('click', async () => {
      // ensure we run in secure context or localhost
      if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
        showNotification('Camera ch·ªâ ho·∫°t ƒë·ªông tr√™n HTTPS ho·∫∑c localhost.', 'error', 6000);
        log('Y√™u c·∫ßu HTTPS ho·∫∑c localhost ƒë·ªÉ truy c·∫≠p camera.', 'status-error');
        return;
      }
      // request a tiny stream to prompt permission and enumerate devices
      try {
        await startCamera(deviceSelect.value || null);
      } catch (e) {
        console.error('openCameraBtn click error', e);
      }
    });

    toggleAutoBtn.addEventListener('click', ()=> {
      isAutoScan = !isAutoScan;
      toggleAutoBtn.textContent = `üîÅ Qu√©t t·ª± ƒë·ªông: ${isAutoScan ? 'ON' : 'OFF'}`;
      if (isAutoScan) startAutoScan(); else stopAutoScan();
    });

    flashToggle.addEventListener('click', async () => {
      if (!currentTrack) { showNotification('Camera ch∆∞a s·∫µn s√†ng ƒë·ªÉ ƒëi·ªÅu khi·ªÉn flash', 'warning'); return; }
      const caps = currentTrack.getCapabilities ? currentTrack.getCapabilities() : {};
      if (!caps.torch) {
        showNotification('Thi·∫øt b·ªã kh√¥ng h·ªó tr·ª£ torch (flash).', 'warning');
        return;
      }
      await setTorch(!torchOn);
    });

    captureBtn.addEventListener('click', captureImageAndDecode);

    searchInput.addEventListener('input', ()=> renderTable(searchInput.value));

    filterStart.addEventListener('input', ()=> { saveLocal(); if (lastCode) filteredEl.textContent = applyFilter(lastCode); });
    filterLength.addEventListener('input', ()=> { saveLocal(); if (lastCode) filteredEl.textContent = applyFilter(lastCode); });

    // ---------- Init ----------
    (async function init(){
      notification.innerHTML = '‚ìò ';
      loadLocal(); renderTable();
      // If insecure and not localhost, show warning (but still allow user to press "M·ªü camera")
      if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
        log('Khuy·∫øn c√°o: c·∫ßn HTTPS ho·∫∑c localhost ƒë·ªÉ truy c·∫≠p camera.', 'status-error');
        showNotification('Trang kh√¥ng ch·∫°y qua HTTPS ‚Äî b·∫°n c·∫ßn HTTPS ho·∫∑c localhost ƒë·ªÉ truy c·∫≠p camera.', 'warning', 6000);
      }

      // Try to prompt permission early so enumerateDevices returns labels
      try {
        // Request minimal permission to get labels; if user denies we still handle gracefully
        const stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
        // stop immediate ‚Äî we just wanted labels / prompt
        stream.getTracks().forEach(t => t.stop());
      } catch (e) {
        // user might deny ‚Äî that's ok, we'll handle when they click m·ªü camera
        console.warn('Permission prompt skipped/denied:', e);
      }

      // Now list devices (labels available if permission granted)
      try { await listCameras(); }
      catch(e){ console.warn('init listCameras err', e); }

      log('·ª®ng d·ª•ng ƒë√£ s·∫µn s√†ng. Nh·∫•n "M·ªü camera" ƒë·ªÉ b·∫Øt ƒë·∫ßu.', 'status-success');
    })();

    // Clean up on unload
    window.addEventListener('pagehide', ()=> stopStream());
    window.addEventListener('beforeunload', ()=> stopStream());
  </script>
</body>
</html>
